<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pac-Man 3D — Arcade FPS</title>
<style>
  html,body{height:100%;margin:0;background:#03060f;color:#bfe9ff;font-family:system-ui,-apple-system,Segoe UI,Inter,Roboto,sans-serif;overflow:hidden}
  #game{display:block;width:100vw;height:100vh}

  /* ===== Minimap + compact HUD (bottom-left) ===== */
  #hudMini{position:fixed;left:12px;bottom:200px;z-index:8;text-shadow:0 1px 0 rgba(0,0,0,.45)}
  #hudMini .row{display:flex;gap:.6rem;align-items:center}
  .pill{padding:2px 8px;border-radius:999px;border:1px solid rgba(191,233,255,.25);background:#0c1326}
  #map{position:fixed;left:12px;bottom:12px;width:160px;height:176px;background:rgba(10,20,40,.86);border:2px solid #2049ff;border-radius:10px;box-shadow:0 0 10px rgba(32,73,255,.35) inset;z-index:8;display:none}

  /* ✚ Crosshair */
  #crosshair{
    position:fixed;top:50%;left:50%;
    width:20px;height:20px;transform:translate(-50%,-50%);
    pointer-events:none;z-index:9;display:none;
  }
  #crosshair::before,#crosshair::after{
    content:"";position:absolute;background:#fff;opacity:.75;
  }
  #crosshair::before{width:2px;height:20px;left:9px;top:0}
  #crosshair::after{width:20px;height:2px;left:0;top:9px}

  /* Lives popup on death */
  #lifePopup{position:fixed;inset:0;display:none;place-items:center;z-index:12}
  #lifePopup .box{padding:12px 18px;border-radius:12px;background:rgba(8,12,24,.75);border:1px solid rgba(191,233,255,.2)}
  .fade{animation:fade .75s ease}
  @keyframes fade{from{opacity:0;transform:translateY(-6px)}to{opacity:1;transform:none}}

  /* ===== Start Screen ===== */
  #startScreen{
    position:fixed;inset:0;z-index:20;display:grid;place-items:center;
    background:radial-gradient(1200px 600px at 50% -20%, #0b1a6e 0%, #06113d 35%, #03060f 70%);
  }
  .menu{
    width:min(90vw,540px);
    background:rgba(6,12,28,.6);
    border:1px solid rgba(191,233,255,.15);
    border-radius:18px;
    padding:28px 26px;
    box-shadow:0 10px 40px rgba(0,0,0,.5), inset 0 0 40px rgba(32,73,255,.1);
    text-align:center;
  }
  .title{font-size:40px;font-weight:800;letter-spacing:.02em;margin:0 0 18px}
  .subtitle{opacity:.8;margin-top:2px;margin-bottom:18px}
  .btn{
    display:block;width:100%;padding:12px 14px;margin:10px 0;border-radius:12px;
    border:1px solid #2049ff;background:#0b1a6e;color:#e7f3ff;font-weight:700;
    box-shadow:0 0 12px rgba(32,73,255,.25) inset;cursor:pointer;transition:transform .08s ease, box-shadow .2s ease, background .2s ease;
  }
  .btn:hover{transform:translateY(-1px);box-shadow:0 0 24px rgba(32,73,255,.45) inset;background:#1233c7}
  .btn.secondary{background:#0c1326;border-color:#2c3e73}
  .credits{margin-top:12px;font-size:12px;opacity:.8}

  /* Panels for Keybinds / Credits */
  .panel{display:none;margin-top:8px;text-align:left;background:rgba(10,18,36,.6);border:1px solid rgba(191,233,255,.14);border-radius:12px;padding:12px}
  .panel h3{margin:0 0 6px;font-size:16px}
  .kbd{padding:2px 6px;border:1px solid #607dff;background:#0c1326;border-radius:6px}
</style>
</head>
<body>
  <canvas id="game"></canvas>

  <!-- Compact HUD above minimap -->
  <div id="hudMini">
    <div class="row">
      <span class="pill">Score: <strong id="score">0</strong></span>
      <span class="pill">Level: <strong id="level">1</strong></span>
    </div>
  </div>
  <canvas id="map" width="160" height="176" aria-label="Minimap"></canvas>
  <div id="crosshair"></div>

  <!-- Lives popup -->
  <div id="lifePopup"><div class="box fade" id="lifeText">Lives: 3</div></div>

  <!-- Start Screen -->
  <div id="startScreen">
    <div class="menu">
      <h1 class="title">PAC-MAN 3D</h1>
      <div class="subtitle">Arcade maze in first-person</div>
      <button id="btnStart" class="btn">Start Game</button>
      <button id="btnKeys" class="btn secondary">Keybinds</button>
      <div id="panelKeys" class="panel">
        <h3>Keybinds</h3>
        <p><span class="kbd">WASD</span> move • Mouse look<br>
           <span class="kbd">Space</span> minimap • <span class="kbd">P</span> pause • <span class="kbd">R</span> reset<br>
           Click in the game to lock the cursor (crosshair “+”)</p>
      </div>
      <button id="btnCredits" class="btn secondary">Credits</button>
      <div id="panelCredits" class="panel">
        <h3>Credits</h3>
        <p>Created by Rodrigo — inspired by the Pac-Man game and Dark Deception playstyle.</p>
      </div>
      <div class="credits">© Rod Space</div>
    </div>
  </div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

/* ==== MENU BEHAVIOUR ==== */
const startScreen = document.getElementById('startScreen');
document.getElementById('btnKeys').onclick = ()=> {
  const p = document.getElementById('panelKeys');
  p.style.display = p.style.display==='block' ? 'none' : 'block';
};
document.getElementById('btnCredits').onclick = ()=> {
  const p = document.getElementById('panelCredits');
  p.style.display = p.style.display==='block' ? 'none' : 'block';
};
document.getElementById('btnStart').onclick = ()=> {
  startScreen.style.display='none';
  boot(); // start the game
  // optional: auto pointer-lock on first click inside canvas
};

/* ===== Grid & EXACT layout (28x31) ===== */
const TILE=2.0, ROWS=31, COLS=28;
const T={PATH:0,WALL:1,POWER:2,GATE:3,HOUSE:4,VOID:9};
const pacman_map = [
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,2,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,2,1],
  [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],
  [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],
  [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1],
  [1,0,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1],
  [1,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1],
  [9,9,9,9,9,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,9,9,9,9,9],
  [9,9,9,9,9,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,9,9,9,9,9],
  [9,9,9,9,9,1,0,1,1,0,1,1,1,3,3,1,1,1,0,1,1,0,1,9,9,9,9,9],
  [1,1,1,1,1,1,0,0,0,0,1,4,4,4,4,4,4,1,0,0,0,0,1,1,1,1,1,1],
  [0,0,0,0,0,0,0,0,0,0,1,4,4,4,4,4,4,1,0,0,0,0,0,0,0,0,0,0],
  [1,1,1,1,1,1,0,0,0,0,1,4,4,4,4,4,4,1,0,0,0,0,1,1,1,1,1,1],
  [9,9,9,9,9,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,9,9,9,9,9],
  [9,9,9,9,9,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,9,9,9,9,9],
  [9,9,9,9,9,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,9,9,9,9,9],
  [1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],
  [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],
  [1,2,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,2,1],
  [1,1,1,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1],
  [1,1,1,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1],
  [1,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1],
  [1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1],
  [1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

/* ===== Three.js scene (arcade look) ===== */
const canvas=document.getElementById('game');
const renderer=new THREE.WebGLRenderer({antialias:true,canvas});
renderer.setSize(innerWidth,innerHeight); renderer.setPixelRatio(devicePixelRatio);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.12;
addEventListener('resize',()=>renderer.setSize(innerWidth,innerHeight));

const scene=new THREE.Scene();
scene.background=new THREE.Color(0x05070f);
scene.fog=new THREE.Fog(0x05070f, 60, 140);

const camera=new THREE.PerspectiveCamera(70,innerWidth/innerHeight,0.1,2000);
scene.add(new THREE.AmbientLight(0x1a2038, 0.95));
const dLight=new THREE.DirectionalLight(0xaec6ff, 0.35); dLight.position.set(12,26,12); scene.add(dLight);

/* Floor */
const TILE_W = COLS*TILE, TILE_H = ROWS*TILE;
const floor=new THREE.Mesh(
  new THREE.PlaneGeometry(TILE_W,TILE_H),
  new THREE.MeshStandardMaterial({color:0x070a16, metalness:.15, roughness:.95})
);
floor.rotation.x=-Math.PI/2; floor.position.set(TILE_W/2,-0.02,TILE_H/2);
scene.add(floor);

/* Neon-brick procedural texture */
function makeNeonBrickTexture(){
  const size=64;
  const c=document.createElement("canvas"); c.width=c.height=size;
  const ctx=c.getContext("2d");
  ctx.fillStyle="#1133ff"; ctx.fillRect(0,0,size,size);
  ctx.strokeStyle="#000"; ctx.lineWidth=2;
  const step=8;
  for(let i=0;i<=size;i+=step){
    ctx.beginPath();ctx.moveTo(i,0);ctx.lineTo(i,size);ctx.stroke();
    ctx.beginPath();ctx.moveTo(0,i);ctx.lineTo(size,i);ctx.stroke();
  }
  const tex=new THREE.CanvasTexture(c);
  tex.wrapS=tex.wrapT=THREE.RepeatWrapping;
  tex.repeat.set(2,2);
  return tex;
}
const brickTex=makeNeonBrickTexture();

/* Build maze */
const wallGeo=new THREE.BoxGeometry(TILE,2.4,TILE);
const wallMat=new THREE.MeshStandardMaterial({
  color:0x1133ff, emissive:0x0d1a7a, emissiveIntensity:1.6,
  metalness:.25, roughness:.25, map:brickTex
});
const gateMat=new THREE.MeshStandardMaterial({color:0x9fd3ff, transparent:true, opacity:.45});
const walls=new THREE.Group(); scene.add(walls);

const pelletGeo=new THREE.BoxGeometry(0.28,0.28,0.28);
const pelletMat=new THREE.MeshStandardMaterial({color:0xffd400,emissive:0xffe97a,emissiveIntensity:1.45,metalness:.6,roughness:.2});
const powerGeo=new THREE.SphereGeometry(0.44,16,16);
const powerMat=new THREE.MeshStandardMaterial({color:0xff6b6b,emissive:0xff4747,emissiveIntensity:1.7,metalness:.4,roughness:.25});

const pellets=new Map(), powers=new Map();

const wx=c=>c*TILE, wz=r=>r*TILE;
const tile=(c,r)=> (r<0||c<0||r>=ROWS||c>=COLS)?T.WALL:pacman_map[r][c];
const isWall=(c,r)=> tile(c,r)===T.WALL || tile(c,r)===T.VOID;
const isGate=(c,r)=> tile(c,r)===T.GATE;

function buildLevel(refill=true){
  walls.clear();
  for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){
    const t = pacman_map[r][c];
    if (t===T.WALL){ const m=new THREE.Mesh(wallGeo,wallMat); m.position.set(wx(c),1.2,wz(r)); walls.add(m); }
    else if (t===T.GATE){ const g=new THREE.Mesh(new THREE.BoxGeometry(TILE,.8,TILE*.2),gateMat); g.position.set(wx(c),.4,wz(r)); walls.add(g); }
  }
  if(refill){
    for (const [,m] of pellets) scene.remove(m); pellets.clear();
    for (const [,m] of powers) scene.remove(m); powers.clear();
    for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){
      const t=pacman_map[r][c];
      if (t===T.POWER){ const m=new THREE.Mesh(powerGeo,powerMat); m.position.set(wx(c),.45,wz(r)); scene.add(m); powers.set(`${r},${c}`,m); }
      else if (t===T.PATH){ const m=new THREE.Mesh(pelletGeo,pelletMat); m.position.set(wx(c),.15,wz(r)); scene.add(m); pellets.set(`${r},${c}`,m); }
    }
  }
}

/* Entities */
const ghosts=[
  {name:'blinky', color:0xff2b2b},
  {name:'pinky',  color:0xff7ad5},
  {name:'inky',   color:0x00e5ff},
  {name:'clyde',  color:0xff9c2b}
].map(g=>({
  ...g, x:14, y:14, dir:'left', speed:2.9, eyes:false,
  mesh:new THREE.Mesh(new THREE.CapsuleGeometry(.8,.6,8,16), new THREE.MeshStandardMaterial({color:g.color,emissive:0x0f1024,emissiveIntensity:.55,metalness:.1,roughness:.35}))
}));
ghosts.forEach(g=>scene.add(g.mesh));

(function placeGhostsInHouse(){
  const house=[];
  for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++) if(pacman_map[r][c]===T.HOUSE) house.push([c,r]);
  if(house.length){
    const mid=house[Math.floor(house.length/2)];
    const offs=[[-1,0],[1,0],[0,-1],[0,1]];
    ghosts.forEach((g,i)=>{ g.x=mid[0]+offs[i%4][0]; g.y=mid[1]+offs[i%4][1]; });
  }
})();

/* Player */
const player={x:13,y:23,speed:3.9};

/* HUD */
const uiScore=document.getElementById('score');
const uiLevel=document.getElementById('level');
const lifePopup=document.getElementById('lifePopup');
const lifeText=document.getElementById('lifeText');

const state={score:0,lives:3,level:1,paused:false,playing:false,fright:0,streak:0,mode:'scatter',modeTime:0};

function showLives(){
  lifeText.textContent = `Lives: ${state.lives}`;
  lifePopup.style.display='grid';
  setTimeout(()=>{lifePopup.style.display='none';},900);
}
function resetPositions(){
  yaw=Math.PI; pitch=0;
  camera.position.set(player.x*TILE,1.26,player.y*TILE);
  camera.rotation.order="YXZ"; camera.rotation.set(0,yaw,0);
  ghosts.forEach(g=>{ g.dir='left'; g.eyes=false; g.speed=2.9+(state.level-1)*0.06; g.mesh.material.color.setHex(g.color); g.mesh.material.emissive.setHex(0x0f1024); });
}
function softReset(){
  state.lives--;
  if (state.lives<0){ state.playing=false; lifeText.textContent='Game Over — R to reset'; lifePopup.style.display='grid'; return; }
  showLives();
  resetPositions();
}
function hardReset(){
  buildLevel(true);
  state.score=0; uiScore.textContent=0; state.lives=3; state.level=1; uiLevel.textContent=1;
  state.paused=false; state.playing=true; state.fright=0; state.streak=0; state.mode='scatter'; state.modeTime=0;
  resetPositions(); showLives();
}
function nextLevel(){
  state.level++; uiLevel.textContent=state.level;
  buildLevel(true); resetPositions();
}

/* Controls & pointer lock */
const keys=new Set();
addEventListener('keydown',e=>{
  keys.add(e.key);
  if(e.key===' '){ e.preventDefault(); toggleMap(); }
  if(e.key==='p'||e.key==='P'){ state.paused=!state.paused; }
  if(e.key==='r'||e.key==='R'){ hardReset(); }
});
addEventListener('keyup',e=>keys.delete(e.key));

const cross=document.getElementById('crosshair');
let lockMode='unlocked';
const pointerLockSupported=()=>!!document.body.requestPointerLock;
function tryPointerLock(){ try{ document.body.requestPointerLock(); }catch{ return false; } return true; }
document.addEventListener('pointerlockchange',()=>{ 
  if(document.pointerLockElement===document.body){
    lockMode='pointer'; cross.style.display='block'; document.body.style.cursor='none';
  } else if(lockMode==='pointer'){
    lockMode='unlocked'; cross.style.display='none'; document.body.style.cursor='';
  }
});
canvas.addEventListener('click',()=>{
  if(lockMode==='unlocked' && pointerLockSupported()) tryPointerLock();
});

/* Mouse look: up=up, down=down; clamp ±60°; no roll */
let yaw=Math.PI, pitch=0;
addEventListener('mousemove',e=>{
  if(lockMode==='unlocked')return;
  yaw   -= e.movementX*0.002;
  pitch -= e.movementY*0.002;
  pitch = Math.max(-Math.PI/3, Math.min(Math.PI/3, pitch));
  camera.rotation.order = "YXZ";
  camera.rotation.set(pitch, yaw, 0);
});

/* Movement & collisions + tunnel row */
const isWalkable=(c,r)=>{ const t=tile(c,r); return t!==T.WALL && t!==T.VOID && !(t===T.GATE); };
function canMoveTo(nx,ny){
  const r=0.18;
  const pts=[[nx-r,ny-r],[nx+r,ny-r],[nx-r,ny+r],[nx+r,ny+r]];
  for(const [x,y] of pts){
    const c=Math.floor(x), rr=Math.floor(y);
    if(!isWalkable(c,rr)) return false;
  }
  return true;
}
function applyTunnelsEntity(obj){
  const row=14;
  if (Math.round(obj.y)===row){
    if (obj.x < 0.5) obj.x = COLS-1.5;
    else if (obj.x > COLS-0.5) obj.x = 1.5;
  }
}
function movePlayer(dt){
  const speed=player.speed*dt;
  const dir=new THREE.Vector3();
  if(keys.has('w')||keys.has('ArrowUp'))dir.z-=1;
  if(keys.has('s')||keys.has('ArrowDown'))dir.z+=1;
  if(keys.has('a')||keys.has('ArrowLeft'))dir.x-=1;
  if(keys.has('d')||keys.has('ArrowRight'))dir.x+=1;
  if(dir.lengthSq()>0){
    dir.normalize();
    const yawOnly=new THREE.Euler(0,camera.rotation.y,0,'YXZ');
    dir.applyEuler(yawOnly);
    const nx=player.x+dir.x*(speed/TILE);
    const ny=player.y+dir.z*(speed/TILE);
    if(canMoveTo(nx,player.y)) player.x=nx;
    if(canMoveTo(player.x,ny)) player.y=ny;
    applyTunnelsEntity(player);
  }
  camera.position.set(player.x*TILE,1.26,player.y*TILE);
}

/* Ghost AI (scatter/chase, frightened) */
const dirs={up:[0,-1],down:[0,1],left:[-1,0],right:[1,0]};
const opposite=d=>({up:'down',down:'up',left:'right',right:'left'})[d];
const atCenter=(x,y)=>Math.abs(x-Math.round(x))<0.15 && Math.abs(y-Math.round(y))<0.15;

function chooseNextDir(g,target){
  if(!atCenter(g.x,g.y)) return;
  const options=['up','left','down','right'];
  let pick=null, best=Infinity;
  for(const d of options){
    if(d===opposite(g.dir)) continue;
    const [dx,dy]=dirs[d];
    const cx=Math.round(g.x), cy=Math.round(g.y);
    const t = tile(Math.floor(cx+dx*0.5),Math.floor(cy+dy*0.5));
    if(t===T.WALL || t===T.VOID) continue; // ghosts pass gate
    const nx=g.x+dx, ny=g.y+dy;
    const d2=(nx-target.x)**2+(ny-target.y)**2;
    if(d2<best){ best=d2; pick=d; }
  }
  g.dir = pick || opposite(g.dir);
}
function randomTurn(g){
  if(!atCenter(g.x,g.y)) return;
  const cx=Math.round(g.x), cy=Math.round(g.y);
  const opts=['up','left','down','right'].filter(d=>{
    const [dx,dy]=dirs[d];
    const t = tile(Math.floor(cx+dx*0.5),Math.floor(cy+dy*0.5));
    return d!==opposite(g.dir) && t!==T.WALL && t!==T.VOID;
  });
  if(opts.length) g.dir=opts[Math.floor(Math.random()*opts.length)];
}
function chaseTarget(g){
  if(g.name==='blinky') return {x:player.x,y:player.y};
  if(g.name==='pinky'){ const fx=Math.sin(yaw), fz=Math.cos(yaw); return {x:player.x+fx*3,y:player.y+fz*3}; }
  if(g.name==='inky'){  const fx=Math.sin(yaw), fz=Math.cos(yaw); return {x:player.x+fx*2+(ghosts[0].x-player.x), y:player.y+fz*2+(ghosts[0].y-player.y)}; }
  const d=Math.hypot(g.x-player.x,g.y-player.y); // clyde
  return d<6? {x:1,y:ROWS-2} : {x:player.x,y:player.y};
}
function ghostAI(g){
  if(g.eyes){
    const home={x:14,y:14}; chooseNextDir(g,home);
    if(Math.hypot(g.x-home.x,g.y-home.y)<0.4){ g.eyes=false; g.speed=2.9+(state.level-1)*0.06; g.mesh.material.color.setHex(g.color); }
    return;
  }
  if(state.fright>0){ randomTurn(g); return; }
  const scatter={blinky:[COLS-2,1],pinky:[1,1],inky:[COLS-2,ROWS-2],clyde:[1,ROWS-2]}[g.name];
  const t=(state.mode==='scatter') ? {x:scatter[0],y:scatter[1]} : chaseTarget(g);
  chooseNextDir(g,t);
}
function moveGhost(g,dt){
  const [dx,dy]=dirs[g.dir]||[0,0];
  const sp=g.speed*dt/TILE;
  const nx=g.x+dx*sp, ny=g.y+dy*sp;
  const tc=tile(Math.floor(nx),Math.floor(ny));
  if(tc!==T.WALL && tc!==T.VOID){ g.x=nx; g.y=ny; }
  applyTunnelsEntity(g);
  g.mesh.position.set(g.x*TILE,1.0,g.y*TILE);
  g.mesh.rotation.y = ({left:Math.PI,right:0,up:-Math.PI/2,down:Math.PI/2}[g.dir]||0);
}

/* Eating & collisions */
function eat(){
  const c=Math.floor(player.x), r=Math.floor(player.y), k=`${r},${c}`;
  if(pellets.has(k)){ scene.remove(pellets.get(k)); pellets.delete(k); state.score+=10; uiScore.textContent=state.score; if(pellets.size===0) nextLevel(); }
  else if(powers.has(k)){ scene.remove(powers.get(k)); powers.delete(k); state.score+=50; uiScore.textContent=state.score; state.fright=6; state.streak=0; ghosts.forEach(g=>{ if(!g.eyes){ g.mesh.material.color.setHex(0x1f6cff); } }); }
}
function checkDeaths(){
  for(const g of ghosts){
    const d=Math.hypot((g.x-player.x)*TILE,(g.y-player.y)*TILE);
    if(d<0.9){
      if(state.fright>0 && !g.eyes){
        g.eyes=true; state.streak++; state.score+=200*(2**(state.streak-1)); uiScore.textContent=state.score; g.speed=3.6;
        g.mesh.material.color.setHex(0xffffff);
      }else if(!g.eyes){ softReset(); return; }
    }
  }
}

/* Minimap bottom-left */
const mapCanvas=document.getElementById('map'), mctx=mapCanvas.getContext('2d');
let mapVisible=false; function toggleMap(){ mapVisible=!mapVisible; mapCanvas.style.display=mapVisible?'block':'none'; }
function drawMap(){
  const cw=mapCanvas.width/COLS, ch=mapCanvas.height/ROWS;
  mctx.fillStyle='rgba(8,16,32,0.9)'; mctx.fillRect(0,0,mapCanvas.width,mapCanvas.height);
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
    const t=pacman_map[r][c];
    if(t===T.WALL) mctx.fillStyle='#2049ff';
    else if(t===T.VOID) mctx.fillStyle='#03060f';
    else mctx.fillStyle='#050a14';
    mctx.fillRect(c*cw,r*ch,cw,ch);
  }
  mctx.fillStyle='#ffd400'; for(const key of pellets.keys()){ const [r,c]=key.split(',').map(Number); mctx.fillRect(c*cw+cw*.35,r*ch+ch*.35,cw*.3,ch*.3); }
  mctx.fillStyle='#ff6b6b'; for(const key of powers.keys()){ const [r,c]=key.split(',').map(Number); mctx.fillRect(c*cw+cw*.25,r*ch+ch*.25,cw*.5,ch*.5); }
  mctx.fillStyle='#ffd400'; mctx.beginPath(); mctx.arc(player.x*cw,player.y*ch,2.6,0,Math.PI*2); mctx.fill();
  ghosts.forEach(g=>{ mctx.save(); mctx.translate(g.x*cw,g.y*ch); const ang={left:Math.PI,right:0,up:-Math.PI/2,down:Math.PI/2}[g.dir]||0; mctx.rotate(ang); mctx.fillStyle=`#${g.color.toString(16).padStart(6,'0')}`; mctx.beginPath(); mctx.moveTo(0,-4); mctx.lineTo(3,3); mctx.lineTo(-3,3); mctx.closePath(); mctx.fill(); mctx.restore(); });
}

/* Boot & loop */
function boot(){ hardReset(); state.playing=true; }
let prev=performance.now();
function loop(now){
  const dt=Math.min(0.033,(now-prev)/1000); prev=now;
  pelletMat.emissiveIntensity = 1.2 + Math.sin(now*0.004)*0.28;

  if(state.playing && !state.paused){
    if(lockMode!=='unlocked') movePlayer(dt);
    ghosts.forEach(g=>{ ghostAI(g); moveGhost(g,dt); });
    eat(); checkDeaths();
    state.modeTime+=dt;
    if(state.fright>0){
      state.fright-=dt;
      if(state.fright<=0){ state.fright=0; ghosts.forEach(g=>{ if(!g.eyes) g.mesh.material.color.setHex(g.color); }); }
    }else if(state.mode==='scatter' && state.modeTime>7){ state.mode='chase'; state.modeTime=0; }
     else if(state.mode==='chase' && state.modeTime>20){ state.mode='scatter'; state.modeTime=0; }
  }
  if(mapVisible) drawMap();
  renderer.render(scene,camera);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
